opt_out_usage

DERIVED_DATA_PATH = "~/Library/Developer/Xcode/DerivedData"

default_platform(:ios)
platform :ios do
  
  before_all do
    # This is required to setup the temporary keychain
    setup_circle_ci
  end
  
  desc "Builds and uploads the app using the dev environment."
  desc "Builds are uploaded to AppCenter."
  desc "Available options: skip_tests | skip_dsym_upload | skip_build_upload"
  lane :dev do | options |
    final_options = options.merge(
      {
        scheme: "Blockchain (Dev)",
        environment: "Dev",
        app_center_app_name: ENV["APPCENTER_APP_NAME_DEV"],
        app_center_app_owner: ENV["APPCENTER_OWNER_NAME_DEV"],
      }
    )
    produce_build(final_options)
  end
  
  desc "Builds and uploads the app using the staging environment."
  desc "Builds are uploaded to AppCenter."
  desc "Available options: skip_tests | skip_dsym_upload | skip_build_upload"
  lane :staging do | options |
    final_options = options.merge(
      {
        scheme: "Blockchain (Staging)",
        environment: "Staging",
        app_center_app_name: ENV["APPCENTER_APP_NAME_STAGING"],
        app_center_app_owner: ENV["APPCENTER_OWNER_NAME_STAGING"],
      }
    )
    produce_build(final_options)
  end
  
  desc "Builds and uploads the app using the production environment but a different bundle ID and enabling internal features."
  desc "Builds are uploaded to TestFlight."
  desc "Available options: skip_tests | skip_dsym_upload | skip_build_upload"
  lane :alpha do | options |
    # Set a specific version number for alpha
    increment_version_number(
      version_number: "999999.9.9"
    )
    # Set a build number equal to number of commits for alpha
    build_number = number_of_commits(all: false).to_s.strip
    increment_build_number(
      build_number: build_number
    )
    final_options = options.merge(
      {
        scheme: "Blockchain (Alpha)",
        environment: "Alpha",
        build_type: "appstore"
      }
    )
    produce_build(final_options)
  end
  
  desc "Builds and uploads the app using the production environment. This version can toggle internal feature flags."
  desc "Builds are uploaded to AppCenter."
  desc "Available options: skip_tests | skip_dsym_upload | skip_build_upload"
  lane :internal_release do | options |
    
    bump_release('Blockchain (Internal Production)')
    
    final_options = options.merge(
      {
        scheme: "Blockchain (Internal Production)",
        environment: "Prod",
        app_center_app_name: ENV["APPCENTER_APP_NAME"],
        app_center_app_owner: ENV["APPCENTER_OWNER_NAME"],
      }
    )
    produce_build(final_options)
  end

  desc "Builds and uploads the app using the production environment."
  desc "Builds are uploaded to TestFlight."
  desc "Available options: skip_tests | skip_dsym_upload | skip_build_upload"
  lane :release do | options |
    
    version, build_number = bump_release('Blockchain')

    tag = "v#{version}-rc.#{build_number}"
    add_git_tag(
      tag: tag
    )
    
    final_options = options.merge(
      {
        scheme: "Blockchain",
        environment: "Prod",
        build_type: "appstore"
      }
    )
    
    produce_build(final_options)
    
    push_git_tags(
      tag: tag
    )
  end
  
  desc "Runs all unit tests on Blockchain (Staging) scheme"
  lane :execute_tests do
    xcargs = {}
    xcargs['CODE_SIGN_IDENTITY'] = ''
    xcargs['CODE_SIGNING_REQUIRED'] = 'NO'
    xcargs['COMPILER_INDEX_STORE_ENABLE'] = 'NO'
    flatten = flatten_xcargs(xcargs)
    clonedSourcesPath = "#{DERIVED_DATA_PATH}/SourcePackages" 
    packageCachePath = "#{DERIVED_DATA_PATH}/PackageCache"
    xcodebuild(
      project: "Blockchain.xcodeproj",
      scheme: "Blockchain (Staging)",
      configuration: "Debug Staging",
      xcargs: flatten + " -destination 'platform=iOS Simulator,name=iPhone 8,OS=16.0' -clonedSourcePackagesDirPath #{clonedSourcesPath} -packageCachePath #{packageCachePath} -disableAutomaticPackageResolution test"
    )
  end
  
  desc "Updates code signing on the current machine"
  lane :code_signing do
    # Global parameters are loaded from the Matchfile
    match(type: "appstore", readonly: is_ci?)
    match(type: "adhoc", force_for_new_devices: true)
    match(type: "development", force_for_new_devices: true)
  end
  
  desc "Upload to TestFlight"
  lane :upload do
    api_key = fetch_app_store_connect_api_key
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier).first
    match(type: "appstore", readonly: true, api_key: api_key)
    upload_to_testflight(
      api_key: api_key,
      app_identifier: app_identifier,
      distribute_external: true,
      groups: ["Blockchain.com"],
      changelog: "Most recent build.",
      ipa: "output/Blockchain.ipa",
      skip_submission: false,
      skip_waiting_for_build_processing: true
    )
  end
  
  desc "Zips all dSYM files required for Crashlytics in the output folder."
  desc "This lane expects a build archive to be present in the output folder."
  lane :gather_dsyms do | options |
    sh "../scripts/gather-dsyms.sh"
  end

  desc "Upload dsyms zip file to Crashlytics. Optional isStaging parameter (defaults to false)."
  lane :upload_dsyms do |options|
    environment = options[:environment] || "Prod"
    # Assumes there is a 'blockchain-dsyms.zip' file in `./output` directory.
    # To create the zip file, execute the following command `fastlane gather_dsyms`
    puts "Uploading dSYMs for environment '#{environment}'"
    upload_symbols_to_crashlytics(
      binary_path: "./scripts/crashlytics/upload-symbols",
      dsym_path: "./output/blockchain-dsyms.zip",
      gsp_path: "./Blockchain/Firebase/#{environment}/GoogleService-Info.plist"
    )
  end
  
  desc "Upload IPA to AppCenter."
  desc "Available options: app_center_app_name | app_center_app_owner."
  lane :upload_to_appcenter do | options |
    #  Expected env vars: 
    #  APPCENTER_API_TOKEN, APPCENTER_DISTRIBUTE_FILE, APPCENTER_OWNER_NAME,
    #  APPCENTER_DISTRIBUTE_DESTINATIONS, APPCENTER_DISTRIBUTE_RELEASE_NOTES and APPCENTER_APP_NAME
    appcenter_upload(
      file: "output/Blockchain.ipa",
      app_name: options[:app_center_app_name],
      owner_name: options[:app_center_app_owner]
    )
  end
  
  # ==== PRIVATE LANES ====

  desc "Performs the entire workflow of running tests, creating a build, and deploying it alongside any supporting metadata."
  desc "Available options: skip_tests | skip_dsym_upload | skip_build_upload"
  private_lane :produce_build do | options |
    run_tests_if_needed(options)
    update_code_signing(options)
    build_and_archive(options)
    upload_dsyms_if_needed(options)
    upload_build_if_needed(options)
    clean_up(options)
  end

  desc "Runs Match for the current configuration."
  private_lane :update_code_signing do | options |
    puts "üîè  Updating Code Signing"
    match(force_for_new_devices: is_ci?)
  end

  desc "Runs Gym for the current configuration."
  private_lane :build_and_archive do | options |
    puts "üèó  Building App"
    xcargs = {}
    xcargs['COMPILER_INDEX_STORE_ENABLE'] = 'NO'
    flattenArgs = flatten_xcargs(xcargs)
    clonedSourcesPath = "#{DERIVED_DATA_PATH}/SourcePackages" 
    packageCachePath = "#{DERIVED_DATA_PATH}/PackageCache"
    xcodebuild(
      clean: false,
      archive: true,
      project: "Blockchain.xcodeproj",
      scheme: options[:scheme],
      output_directory: "output",
      archive_path: "output/Blockchain.xcarchive",
      xcargs: flattenArgs + " -destination 'generic/platform=iOS' -clonedSourcePackagesDirPath #{clonedSourcesPath} -packageCachePath #{packageCachePath} -disableAutomaticPackageResolution"
    )
    puts "üèó Exporting archive"
    # we only care exporting the `xcarchive` from previous build at this point
    build_app(
      clean: false,
      skip_package_dependencies_resolution: true,
      skip_build_archive: true,
      archive_path: "output/Blockchain.xcarchive",
      output_directory: "output",
      output_name: "Blockchain.ipa",
      xcargs: flattenArgs + " -clonedSourcePackagesDirPath #{clonedSourcesPath} -packageCachePath #{packageCachePath} -disableAutomaticPackageResolution",
    )
  end
  
  private_lane :run_tests_if_needed do | options |
    skip_tests = options.fetch(:skip_tests, not(is_ci?))
    unless skip_tests
      puts "üß™  Running tests"
      execute_tests
    else
      puts "üß™  Skipping tests"
    end
  end
  
  private_lane :upload_dsyms_if_needed do | options |
    skip_dsym_upload = options.fetch(:skip_dsym_upload, not(is_ci?))
    unless skip_dsym_upload
      puts "üêõ  Uploading dSYMs"
      gather_dsyms(options)
      upload_dsyms(options)
    else
      puts "üêõ  Skipping dSYMs upload"
    end
  end
  
  private_lane :upload_build_if_needed do | options |
    skip_build_upload = options.fetch(:skip_build_upload, not(is_ci?))
    unless skip_build_upload
      puts "üöÄ  Uploading build"
      if is_adhoc_build = is_adhoc_build_type?(options)
        upload_to_appcenter(options)
      else
        upload
      end
    else
      puts "üöÄ  Skipping build upload"
    end
  end

  private_lane :clean_up do | options |
    # On CI, remove Xcode's build archive so it doesn't pollute stored artifacts
    sh "rm -rf ../output/Blockchain.xcarchive" if is_ci?
  end
  
  # ==== Helper Functions ====
  
  def bump_release(scheme)
    if match = git_branch.match(/release\/(?<version>\d{6}\.\d+\.\d+)/i)
      version = match[:version]
      increment_version_number(
        version_number: version
      )
    else 
      UI.user_error!("You can only run this lane from a release branch. Exiting.")
    end

    build_number = number_of_commits(all: false).to_s.strip
    increment_build_number(
      build_number: build_number
    )
    
    return [version, build_number]
  end
  
  def is_adhoc_build_type?(options)
    build_type = options[:build_type] || "adhoc"
    build_type == "adhoc"
  end
  
  def fetch_app_store_connect_api_key
    app_store_connect_api_key(
      key_id: ENV["APPSTORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APPSTORE_CONNECT_API_ISSUER_ID"],
      key_content: ENV["APPSTORE_CONNECT_API_KEY_CONTENT"]
    )
  end

  def flatten_xcargs(xcargs)
    xcargs.map{|k,v| "#{k}=\"#{v}\""}.join(' ')
  end
end
